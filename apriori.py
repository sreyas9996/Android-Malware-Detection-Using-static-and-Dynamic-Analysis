
"""
Description     : Simple Python implementation of the Apriori Algorithm

Usage:
    $python apriori.py -f DATASET.csv -s minSupport  -c minConfidence

    $python apriori.py -f DATASET.csv -s 0.15 -c 0.6
"""

import sys
import csv
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import operator
from collections import OrderedDict
from itertools import chain, combinations
from collections import defaultdict
from optparse import OptionParser
from itertools import izip


def subsets(arr):
    """ Returns non empty subsets of arr"""
    return chain(*[combinations(arr, i + 1) for i, a in enumerate(arr)])


def returnItemsWithMinSupport(itemSet, transactionList, minSupport, freqSet):
        """calculates the support for items in the itemSet and returns a subset
       of the itemSet each of whose elements satisfies the minimum support"""
        _itemSet = set()
        localSet = defaultdict(int)

        for item in itemSet:
                for transaction in transactionList:
                        if item.issubset(transaction):
                                freqSet[item] += 1
                                localSet[item] += 1

        for item, count in localSet.items():
                support = float(count)/len(transactionList)

                if support >= minSupport:
                        _itemSet.add(item)

        return _itemSet


def joinSet(itemSet, length):
        """Join a set with itself and returns the n-element itemsets"""
        return set([i.union(j) for i in itemSet for j in itemSet if len(i.union(j)) == length])


def getItemSetTransactionList(data_iterator):
    transactionList = list()
    itemSet = set()
    for record in data_iterator:
        transaction = frozenset(record)
        transactionList.append(transaction)
        for item in transaction:
            itemSet.add(frozenset([item]))              # Generate 1-itemSets
    return itemSet, transactionList


def runApriori(data_iter, minSupport, minConfidence):
    """
    run the apriori algorithm. data_iter is a record iterator
    Return both:
     - items (tuple, support)
     - rules ((pretuple, posttuple), confidence)
    """
    itemSet, transactionList = getItemSetTransactionList(data_iter)
    print len(transactionList)
    freqSet = defaultdict(int)
    largeSet = dict()
    # Global dictionary which stores (key=n-itemSets,value=support)
    # which satisfy minSupport

    assocRules = dict()
    # Dictionary which stores Association Rules

    oneCSet = returnItemsWithMinSupport(itemSet,
                                        transactionList,
                                        minSupport,
                                        freqSet)

    currentLSet = oneCSet
    k = 2
    while(currentLSet != set([])):
        largeSet[k-1] = currentLSet
        currentLSet = joinSet(currentLSet, k)
        currentCSet = returnItemsWithMinSupport(currentLSet,
                                                transactionList,
                                                minSupport,
                                                freqSet)
        currentLSet = currentCSet
        k = k + 1

    def getSupport(item):
            """local function which Returns the support of an item"""
            return float(freqSet[item])/len(transactionList)

    toRetItems = []
    for key, value in largeSet.items():
        toRetItems.extend([(tuple(item), getSupport(item))
            for item in value])

    toRetRules = []
    for key, value in largeSet.items()[1:]:
        for item in value:
            _subsets = map(frozenset, [x for x in subsets(item)])
            for element in _subsets:
                remain = item.difference(element)
                if len(remain) > 0:
                    confidence = getSupport(item)/getSupport(element)
                    if confidence >= minConfidence:
                        toRetRules.append(((tuple(element), tuple(remain)),confidence))
    return toRetItems, toRetRules


def printResults(items1,items2, rules1,rules2):
    """prints the generated itemsets sorted by support and the confidence rules sorted by confidence"""
    mydic1=dict()
    mydic2=dict()
    mydic3=dict()
    mydic4=dict()
    mydic5=dict()
    mydic5=dict()
    mydic6=dict()
    ydic1=dict()
    ydic2=dict()
    ydic3=dict()
    ydic4=dict()
    ydic5=dict()
    ydic5=dict()
    ydic6=dict()
    c1=c2=c3=c4=c5=c6=0
    for item, support in sorted(items1, key=lambda (item, support): support):
        if len(item)==1 :
            mydic1[str(item)] = support
        elif len(item)==2 :
            mydic2[str(item)] = support
        elif len(item)==3 :
            mydic3[str(item)] = support
        elif len(item)==4 :
            mydic4[str(item)] = support
        elif len(item)==5 :
            mydic5[str(item)] = support
        elif len(item)==6 :
            mydic6[str(item)] = support
    for item, support in sorted(items2, key=lambda (item, support): support):
        if len(item)==1 :
            ydic1[str(item)] = support
        elif len(item)==2 :
            ydic2[str(item)] = support
        elif len(item)==3 :
            ydic3[str(item)] = support
        elif len(item)==4 :
            ydic4[str(item)] = support
        elif len(item)==5 :
            ydic5[str(item)] = support
        elif len(item)==6 :
            ydic6[str(item)] = support
    print ydic1
    od1 = OrderedDict(sorted(mydic1.items(), key= lambda(k,v):(v,k),reverse=True)[:13])
    od2 = OrderedDict(sorted(mydic2.items(), key= lambda(k,v):(v,k),reverse=True)[:30])
    od3 = OrderedDict(sorted(mydic3.items(), key= lambda(k,v):(v,k),reverse=True)[:40])
    od4 = OrderedDict(sorted(mydic4.items(), key= lambda(k,v):(v,k),reverse=True)[:40])
    od5 = OrderedDict(sorted(mydic5.items(), key= lambda(k,v):(v,k),reverse=True)[:40])
    od6 = OrderedDict(sorted(mydic6.items(), key= lambda(k,v):(v,k),reverse=True)[:40])
    
    odb1=OrderedDict()
    odb2=OrderedDict()
    odb3=OrderedDict()
    odb4=OrderedDict()
    odb5=OrderedDict()
    odb6=OrderedDict()

    for key in od1.keys():
        try:
            odb1[key]=ydic1[key]
        except Exception:
            odb1[key]=0
            continue
    print odb1
    for key,value in od2.items():
        try:
            odb2[key]=ydic2[key]
        except Exception:
            odb2[key]=0
            continue
    for key,value in od3.items():
        try:
            odb3[key]=ydic3[key]
        except Exception:
            odb3[key]=0
    for key,value in od4.items():
        try:
            odb4[key]=ydic4[key]
        except Exception:
            odb4[key]=0
    for key,value in od5.items():
        try:
            odb5[key]=ydic5[key]
        except Exception:
            odb5[key]=0
    for key,value in od6.items():
        try:
            odb6[key]=ydic6[key]
        except Exception:
            odb6[key]=0
    
    N = 13
    men_means = od1.values()
    ind = np.arange(N)  # the x locations for the groups
    width = 0.15       # the width of the bars
    fig, ax = plt.subplots(figsize=(13,7))
    rects1 = ax.bar(ind, men_means, width, color='r')
    women_means = odb1.values()
    rects2 = ax.bar(ind + width, women_means, width, color='y')
    ax.set_ylabel('Frequency')
    ax.set_xlabel('Permissions')
    ax.set_title('N=1')
    plt.xticks(range(len(od1)), od1.keys(),rotation=60,ha="right")
    ax.legend((rects1[0], rects2[0]), ('Malware', 'Beningn'))
    plt.grid(True)
    plt.tight_layout()
    plt.show()
    fig.savefig("1.png")
    N = 30
    men_means = od2.values()
    ind = np.arange(N)  # the x locations for the groups
    width = 0.35       # the width of the bars
    fig, ax = plt.subplots(figsize=(13,7))
    rects1 = ax.bar(ind, men_means, width, color='r')
    women_means = odb2.values()
    rects2 = ax.bar(ind + width, women_means, width, color='y')
    ax.set_ylabel('Frequency')
    ax.set_xlabel('Permissions')
    ax.set_title('N=2')
    plt.xticks(range(len(od2)), od2.keys(),rotation=60,ha="right")
    ax.legend((rects1[0], rects2[0]), ('Malware', 'Beningn'))
    plt.grid(True)
    plt.tight_layout()
    plt.show()
    fig.savefig("2.png")
    '''
    N = 40
    men_means = od3.values()
    ind = np.arange(N)  # the x locations for the groups
    width = 0.35       # the width of the bars
    fig, ax = plt.subplots(figsize=(13,7))
    rects1 = ax.bar(ind, men_means, width, color='r')
    women_means = odb3.values()
    rects2 = ax.bar(ind + width, women_means, width, color='y')
    ax.set_ylabel('Frequency')
    ax.set_xlabel('Permissions')
    ax.set_title('N=3')
    plt.xticks(range(len(od3)), od3.keys(),rotation=60,ha="right")
    ax.legend((rects1[0], rects2[0]), ('Malware', 'Beningn'))
    plt.grid(True)
    plt.tight_layout()
    plt.show()
    fig.savefig("3.png")
    '''
    keys, values, values1, diff = [], [], [], []
    for key, value in od3.items():
        keys.append(key)
        values.append(value)
        values1.append(odb3[key])
        diff.append(value-odb3[key])
    with open("3.csv", "wb") as outfile:
        csvwriter = csv.writer(outfile)
        for row in izip(keys,values,values1,diff):
            csvwriter.writerow(row)
    outfile.close()
    keys, values, values1, diff = [], [], [], []
    for key, value in od4.items():
        keys.append(key)
        values.append(value)
        values1.append(odb4[key])
        diff.append(value-odb4[key])
    with open("4.csv", "wb") as outfile:
        csvwriter = csv.writer(outfile)
        for row in izip(keys,values,values1,diff):
            csvwriter.writerow(row)
    outfile.close()

    keys, values, values1,diff = [], [], [], []
    for key, value in od5.items():
        keys.append(key)
        values.append(value)
        values1.append(odb5[key])
        diff.append(value-odb5[key])
    with open("5.csv", "wb") as outfile:
        csvwriter = csv.writer(outfile)
        for row in izip(keys,values,values1,diff):
            csvwriter.writerow(row)
    outfile.close()
    keys, values, values1, diff = [], [], [], []
    for key, value in od6.items():
        keys.append(key)
        values.append(value)
        values1.append(odb6[key])
        diff.append(value-odb6[key])
    with open("6.csv", "wb") as outfile:
        csvwriter = csv.writer(outfile)
        for row in izip(keys,values,values1,diff):
            csvwriter.writerow(row)
    outfile.close()
'''
    N = 10
    men_means = od4.values()
    ind = np.arange(N)  # the x locations for the groups
    width = 0.35       # the width of the bars
    fig, ax = plt.subplots(figsize=(13,7))
    rects1 = ax.bar(ind, men_means, width, color='r')
    women_means = odb4.values()
    rects2 = ax.bar(ind + width, women_means, width, color='y')
    ax.set_ylabel('Frequency')
    ax.set_xlabel('Permissions')
    ax.set_title('N=4')
    plt.xticks(range(len(od4)), od4.keys(),rotation=60,ha="right")
    ax.legend((rects1[0], rects2[0]), ('Malware', 'Beningn'))
    plt.grid(True)
    plt.tight_layout()
    plt.show()
    fig.savefig("4.png")
    N = 10
    men_means = od5.values()
    ind = np.arange(N)  # the x locations for the groups
    width = 0.35       # the width of the bars
    fig, ax = plt.subplots(figsize=(13,7))
    rects1 = ax.bar(ind, men_means, width, color='r')
    women_means = odb1.values()
    rects2 = ax.bar(ind + width, women_means, width, color='y')
    ax.set_ylabel('Frequency')
    ax.set_xlabel('Permissions')
    ax.set_title('N=5')
    plt.xticks(range(len(od5)), od5.keys(),rotation=60,ha="right")
    ax.legend((rects1[0], rects2[0]), ('Malware', 'Beningn'))
    plt.grid(True)
    plt.tight_layout()
    plt.show()
    fig.savefig("5.png")
    N = 10
    men_means = od6.values()
    ind = np.arange(N)  # the x locations for the groups
    width = 0.35       # the width of the bars
    fig, ax = plt.subplots(figsize=(13,7))
    rects1 = ax.bar(ind, men_means, width, color='r')
    women_means = odb6.values()
    rects2 = ax.bar(ind + width, women_means, width, color='y')
    ax.set_ylabel('Frequency')
    ax.set_xlabel('Permissions')
    ax.set_title('N=6')
    plt.xticks(range(len(od6)), od6.keys(),rotation=60,ha="right")
    ax.legend((rects1[0], rects2[0]), ('Malware', 'Beningn'))
    plt.grid(True)
    plt.tight_layout()
    plt.show()
    fig.savefig("6.png")
'''


def dataFromFile(fname):
        """Function which reads from the file and yields a generator"""
      
        with open(fname,"rb") as res:
            reader=csv.reader(res)
            header=reader.next()
            column={}
            i=0
            for row in reader:
                i=i+1
                column[i]=[]
                for h, v in zip(header, row):
                    if v=="1":
                        column[i].append(h.lstrip("android.permission."))  
                line=",".join(column[i])                      # Remove trailing comma
                record = frozenset(line.split(','))

                yield record


if __name__ == "__main__":
    optparser = OptionParser()
    optparser.add_option('-f', '--inputFile1',
                         dest='input1',
                         help='filename containing csv',
                         default=None)
    optparser.add_option('-g', '--inputFile2',
                         dest='input2',
                         help='filename containing csv',
                         default=None)
    optparser.add_option('-s', '--minSupport',
                         dest='minS',
                         help='minimum support value',
                         default=0.10,
                         type='float')
    optparser.add_option('-c', '--minConfidence',
                         dest='minC',
                         help='minimum confidence value',
                         default=0.6,
                         type='float')

    (options, args) = optparser.parse_args()

    inFile1 = None
    inFile2 = None
    if options.input1 is None:
        inFile1 = sys.stdin
    elif options.input1 is not None:
        inFile1 = dataFromFile(options.input1)
    else:
        print 'No dataset filename specified, system with exit\n'
        sys.exit('System will exit')
    if options.input2 is None:
        inFile2=sys.stdin
    elif options.input2 is not None:
        inFile2 = dataFromFile(options.input2)
    else:
        print 'No dataset filename specified, system with exit\n'
        sys.exit('System will exit')
    
    
    minSupport = options.minS
    minConfidence = options.minC

    items1, rules1 = runApriori(inFile1, 0.3, 0.3)
    items2, rules2 = runApriori(inFile2, 0.05, 0.05)

    printResults(items1,items2,rules1,rules2)
